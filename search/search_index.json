{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"helix-py-api","text":"<p>Helix Py API</p> <p>Unofficial API for managing Line 6 Helix files and related devices</p> <p> </p>"},{"location":"#overview","title":"Overview","text":"<p><code>Helix-py-api</code> is the unofficial API for managing Line 6 Helix files and related devices. It includes features for editing, standardizing, importing/exporting, renaming, reordering, and cloning bundles, setlists, presets, and snapshots. You can easily build setlists and presets from separate files as well as breakup bundles and setlists into individual setlist and preset files. It also includes simplified MIDI control (i.e. no MIDI message format/value knowledge needed) for Helix hardware and software (Helix Native) as well as direct MIDI control for other Line 6 (ex. FBV) and 3rd party devices. </p> <p><code>Helix-py-api</code> will open up a new world of possibilities. Here are a few ideas to get you started:</p> <ul> <li>Automatically change to a specific setlist, preset, and or snapshot with one click (i.e. script, button, etc) <ol> <li>ex. Change on your Helix, your co-guitarist, your bass player, or all at once </li> </ol> <li>Cleanup all your setlist, preset and snapshot names: <ol> <li>ex. Uppercase, no special characters, etc</li> <li>ex. Change \"Lead\" to \"Solo\", \"New Preset\" to \"\"</li> </ol> <li>Standardize snapshot colors (for every preset in every setlist) to your desired criteria (ex. SOLO=red, CLEAN=WHITE, etc)</li> <li>Easily mass import a ton of presets into a single setlist <ol> <li>ex. After you downloaded bunch of presets from CustomTone</li> </ol> </li> <li>Individually backup all your presets to Github</li>"},{"location":"#current-limitations","title":"Current Limitations","text":"<p>Until time, knowledge, and desire permits to add new features, below are some notable limitations. </p>"},{"location":"#helix","title":"Helix","text":"<ul> <li>Reading state/changes directly from the Helix</li> <li>Importing/exporting files to/from the Helix</li> <li>Anything not exposed in the API (ex. blocks, IRs, favorites, etc)</li> </ul>"},{"location":"#helix-native","title":"Helix Native","text":"<ul> <li>Controlling Helix Native requires a virtual MIDI cable: https://springbeats.com/2016/12/10/springbeats-free-virtual-midi-cable/</li> <li>Helix Native midi control through VST's is severely limited as stated in the Helix Native product manual:     AU and AAX Plugin Formats Only: At this time, remote MIDI control of setlist and preset changes is supported only with the AU (Mac) and Pro Tools AAX (Mac and Windows) Helix Native plugin formats. It is not supported for the VST2 or VST3 Helix Native plugin formats on Mac or Windows.</li> </ul>"},{"location":"#support-the-project","title":"Support the Project","text":"<p>If you find this project useful, please consider supporting it to help with ongoing development and maintenance:</p> <p></p> <p>Your contributions are greatly appreciated!</p>"},{"location":"#getting-started","title":"Getting Started","text":"<p>Download and install the API</p> <pre><code>git clone https://github.com/HackLabsGuitar/`Helix-py-api`.git\ncd `Helix-py-api`\npip install -r requirements.txt\n</code></pre> <p>Optionally change any default settings.</p> <p>Create an API instance.</p> <pre><code>import helixapi\n\nhelix = Helix()\n</code></pre> <p>This will load a default empty bundle template. You can instead load your own bundle:</p> <pre><code>import helixapi\n\nhelix = Helix(file_path=\"/path/to/bundle.hlb\")\n</code></pre>"},{"location":"#usage-examples","title":"Usage Examples","text":"<p>The full API of this library can be found in the API reference.</p> <pre><code># Example: Import/export files\nhelix.setlists[1].import_setlist(file_path=\"/path/to/setlist.hls\")\nhelix.bundle.export_bundle(file_path=\"/path/to/bundle.hlb\")\n</code></pre> <pre><code># Example: Import multiple/export to individual files\nhelix.setlists[4].presets.import_presets(file_paths=[\"/path/to/preset1.hlx\", \"/path/to/preset2.hlx\"])\nhelix.setlists.export_setlists(file_path=\"/path/to/setlists\")\n</code></pre> <pre><code># Example: Change properties of a setlist, preset, or snapshot\nhelix.setlists[0].name = \"Setlist 1\"\nhelix.setlists[1].presets[0]. = \"Set2-Pres1\"\nhelix.setlists[0].presets[0].snapshots[0].name = \"Snapshot 1\"\n\nimport helixapi.snapshot.LEDColor as LEDColor\nhelix.setlists[0].presets[0].snapshots[0].ledcolor = LEDColor.RED\n</code></pre> <pre><code># Example: loop through items\nfor setlist in helix.setlists:\n    print(setlist.name)\n\n    for preset in setlist.presets:\n        print(preset.name)\n\n        for snapshot in preset.snapshots:\n            print(snapshot.name)\n</code></pre> <pre><code># Example: standardize setlists, presets, and snapshots\nhelix.setlists.standardize()\nfor setlist in helix.setlists:      \n    setlist.presets.standardize()\n    for preset in setlist.presets:\n        preset.snapshots.standardize()\n</code></pre>"},{"location":"#licensing","title":"Licensing","text":"<p>Copyright 2024 Hack Labs Guitar</p> <p>Licensed under the BSD 3-Clause License (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <p>https://opensource.org/licenses/BSD-3-Clause</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p> <p>A copy of the license is available in the repository's LICENSE file.</p>"},{"location":"bundle/","title":"Bundle","text":"<p>Module for managing Helix bundle files.</p>"},{"location":"bundle/#helixapi.bundle.Bundle","title":"<code>Bundle</code>","text":"<p>Class representing a Helix bundle file.</p> <p>This class provides methods to import and export Helix bundle files.</p> <p>Note</p> <p>This class is not intended to be instantiated directly. Please access it through an instantiated <code>Helix</code> object.</p> <p>Example: <pre><code>helix = Helix()\nbundle = helix.bundle\n</code></pre></p> Source code in <code>helixapi\\bundle.py</code> <pre><code>class Bundle:\n    \"\"\"\n    Class representing a Helix bundle file.\n\n    This class provides methods to import and export Helix bundle files.\n\n    !!! note\n\n        This class is not intended to be instantiated directly.\n        Please access it through an instantiated `Helix` object.\n\n        Example:\n        ```py\n        helix = Helix()\n        bundle = helix.bundle\n        ```\n    \"\"\"\n\n    def __init__(self, file_path=None, setlists_callback=None):\n        \"\"\"\n        Initialize the Bundle class.\n\n        Args:\n            file_path (str, optional): Path to the bundle file to load. Defaults to None.\n\n        Examples:\n        ``` py\n        bundle = Bundle()\n        ```\n\n        Returns:\n            None\n        \"\"\"\n        self._setlists_callback = setlists_callback\n        self.import_bundle(file_path)\n\n    @property\n    def name(self):\n        \"\"\"\n        Get the name of the bundle.\n\n        Returns:\n            str: The name of the bundle.\n        \"\"\"\n        return self.metadata['meta']['name']\n\n    @name.setter\n    def name(self, value):\n        \"\"\"\n        Set the name of the bundle.\n\n        Args:\n            value (str): The name of the bundle.\n        \"\"\"\n        self.data['meta']['name'] = value\n\n    def export_bundle(self, file_path=None):\n        \"\"\"\n        Export the bundle to a file.\n\n        Args:\n            file_path (str): Path to export the bundle file to.\n\n        Raises:\n            Exception: If the file path is not specified or the file type is incorrect.\n        \"\"\"\n        logging.debug(f\"Exporting bundle: {file_path}\")\n\n        if not file_path:\n            raise Exception('File path must be specified.')\n        elif FileType.get_type(file_path) == FileType.BUNDLE:\n            Files._export_file(file_path=file_path, data=self.data, metadata=self.metadata)\n        else:\n            raise Exception('File type must be a bundle.')\n\n    def import_bundle(self, file_path=None):\n        \"\"\"\n        Import the bundle from a file.\n\n        Args:\n            file_path (str): Path to the bundle file to import.\n\n        Raises:\n            Exception: If the file path is not specified or the file type is incorrect.\n        \"\"\"\n        logging.debug(f\"Importing bundle: {file_path}\")\n\n        if not file_path:\n            self.data, self.metadata = Files._import_file(TemplatePath.BUNDLE.value)            \n        elif FileType.get_type(file_path) == FileType.BUNDLE:\n            self.data, self.metadata = Files._import_file(file_path)\n        else:\n            raise Exception('File path must be a bundle or None (to load the bundle template).')\n\n        # Call the callback to notify Helix to reload setlists\n        if self._setlists_callback:\n            self._setlists_callback(self.data)\n</code></pre>"},{"location":"bundle/#helixapi.bundle.Bundle.name","title":"<code>name</code>  <code>property</code> <code>writable</code>","text":"<p>Get the name of the bundle.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>The name of the bundle.</p>"},{"location":"bundle/#helixapi.bundle.Bundle.export_bundle","title":"<code>export_bundle(file_path=None)</code>","text":"<p>Export the bundle to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to export the bundle file to.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the file path is not specified or the file type is incorrect.</p> Source code in <code>helixapi\\bundle.py</code> <pre><code>def export_bundle(self, file_path=None):\n    \"\"\"\n    Export the bundle to a file.\n\n    Args:\n        file_path (str): Path to export the bundle file to.\n\n    Raises:\n        Exception: If the file path is not specified or the file type is incorrect.\n    \"\"\"\n    logging.debug(f\"Exporting bundle: {file_path}\")\n\n    if not file_path:\n        raise Exception('File path must be specified.')\n    elif FileType.get_type(file_path) == FileType.BUNDLE:\n        Files._export_file(file_path=file_path, data=self.data, metadata=self.metadata)\n    else:\n        raise Exception('File type must be a bundle.')\n</code></pre>"},{"location":"bundle/#helixapi.bundle.Bundle.import_bundle","title":"<code>import_bundle(file_path=None)</code>","text":"<p>Import the bundle from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the bundle file to import.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the file path is not specified or the file type is incorrect.</p> Source code in <code>helixapi\\bundle.py</code> <pre><code>def import_bundle(self, file_path=None):\n    \"\"\"\n    Import the bundle from a file.\n\n    Args:\n        file_path (str): Path to the bundle file to import.\n\n    Raises:\n        Exception: If the file path is not specified or the file type is incorrect.\n    \"\"\"\n    logging.debug(f\"Importing bundle: {file_path}\")\n\n    if not file_path:\n        self.data, self.metadata = Files._import_file(TemplatePath.BUNDLE.value)            \n    elif FileType.get_type(file_path) == FileType.BUNDLE:\n        self.data, self.metadata = Files._import_file(file_path)\n    else:\n        raise Exception('File path must be a bundle or None (to load the bundle template).')\n\n    # Call the callback to notify Helix to reload setlists\n    if self._setlists_callback:\n        self._setlists_callback(self.data)\n</code></pre>"},{"location":"helix/","title":"Helix","text":""},{"location":"helix/#helixapi.helix.Helix","title":"<code>Helix(file_path=None)</code>","text":"<p>Main entry point for interacting with Helix files and devices.</p> <p>This class provides methods for loading Helix bundle files and managing setlists.</p> <p>Initialize the Helix class.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the bundle file to load. Defaults to None.</p> <code>None</code> <p>Examples: <pre><code>helix = Helix()\n</code></pre></p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>helixapi\\helix.py</code> <pre><code>def __init__(self, file_path=None) -&gt; None:\n    \"\"\"\n    Initialize the Helix class.\n\n    Args:\n        file_path (str, optional): Path to the bundle file to load. Defaults to None.\n\n    Examples:\n    ``` py\n    helix = Helix()\n    ```\n\n    Returns:\n        None\n    \"\"\"\n    # Load settings\n    self._settings = Settings()\n\n    # Setup logging\n    self._setup_logging(log_level=self._settings.log_level)\n\n    self.midi = MIDI()\n\n    # Initialize _setlists to None\n    self._setlists = None\n\n    # Load the bundle (which also loads the setlist, presets, snapshots, etc)\n    self._bundle = Bundle(file_path=file_path, setlists_callback=self._reload_setlists)\n</code></pre>"},{"location":"helix/#helixapi.helix.Helix.bundle","title":"<code>bundle</code>  <code>property</code>","text":"<p>Get the loaded bundle.</p> <p>Returns:</p> Name Type Description <code>Bundle</code> <p>The loaded bundle.</p> <p>Examples: <pre><code>helix.bundle\n</code></pre></p>"},{"location":"helix/#helixapi.helix.Helix.midi","title":"<code>midi = MIDI()</code>  <code>instance-attribute</code>","text":""},{"location":"helix/#helixapi.helix.Helix.setlists","title":"<code>setlists: Setlists</code>  <code>property</code> <code>writable</code>","text":"<p>Get the setlists for the current bundle.</p> <p>Returns:</p> Name Type Description <code>Setlists</code> <code>Setlists</code> <p>The setlists for the current bundle.</p> <p>Examples: <pre><code>helix.setlists\n</code></pre></p>"},{"location":"midi/","title":"Midi","text":""},{"location":"midi/#helixapi.midi.MIDI","title":"<code>MIDI</code>","text":"<p>Manages all MIDI communication and target devices</p> <ul> <li>System class - (mostly for internal use) provides methods for interacting with all MIDI output ports and sending messages.</li> <li>Targets class - represents the desired MIDI output ports (aka targets) to use when sending commands.</li> <li>Commands class - provides easy to use (no MIDI knowledge required) methods for sending commands to targets.</li> </ul> <p>Note</p> <p>The corresponding commands will automatically be called when the active setlist, preset, or snapshot changes.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>class MIDI:\n    \"\"\"\n    Manages all MIDI communication and target devices\n\n    * System class - (mostly for internal use) provides methods for interacting with all MIDI output ports and sending messages.\n    * Targets class - represents the desired MIDI output ports (aka targets) to use when sending commands.\n    * Commands class - provides easy to use (no MIDI knowledge required) methods for sending commands to targets.\n\n    !!! note\n        The corresponding commands will automatically be called when the active setlist, preset, or snapshot changes.    \n    \"\"\"\n\n    _instance = None\n\n    def __new__(cls, *args, **kwargs):\n        if cls._instance is None:\n            cls._instance = super(MIDI, cls).__new__(cls, *args, **kwargs)\n        return cls._instance\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the MIDI class with settings and devices.\"\"\"\n        if not hasattr(self, '_initialized'):  # Ensure the class is only initialized once\n            self.system = self.System()\n            self.targets = self.Targets(self.system)\n            self.commands = self.Commands(self.targets)\n            logging.debug(\"MIDI initialized with targets: %s\", self.targets)\n            self._initialized = True\n\n    class System:\n        \"\"\"\n        System class for managing MIDI output ports and sending messages.\n\n        !!! note\n\n            While this class is mostly for internal use, it can be used to list MIDI output ports and send messages.\n            Most users should use the Commands class instead.\n        \"\"\"\n        def __init__(self) -&gt; None:\n            self._available_ports = mido.get_output_names()\n\n        @property\n        def ports(self) -&gt; List[str]:\n            \"\"\"\n            Return a list of available MIDI output ports.\n\n            Returns:\n                List[str]: A list of available MIDI output ports.\n            \"\"\"\n            logging.debug(\"Available MIDI ports: %s\", self._available_ports)\n            return self._available_ports\n\n        def send_cc(self, port: str, channel: int, control: int, value: int) -&gt; None:\n            \"\"\"\n            Send a Control Change (CC) message to a MIDI target.\n\n            Args:\n                port (str): The name of the MIDI output port.\n                channel (int): The MIDI channel to send the message on.\n                control (int): The control number.\n                value (int): The value to set the control to.\n            \"\"\"\n            message = self._create_cc_message(channel, control, value)\n            logging.debug(\"Sending CC message: %s\", message)\n            self._send_message(port, message)\n\n        def send_pc(self, port: str, channel: int, program: int) -&gt; None:\n            \"\"\"\n            Send a Program Change (PC) message to a MIDI target.\n\n            Args:\n                port (str): The name of the MIDI output port.\n                channel (int): The MIDI channel to send the message on.\n                program (int): The program number to change to.\n            \"\"\"\n            message = self._create_pc_message(channel, program)\n            logging.debug(\"Sending PC message: %s\", message)\n            self._send_message(port, message)\n\n        def send_ccpc(self, port: str, cc_channel: int, cc_control: int, cc_value: int, pc_channel: int, pc_program: int) -&gt; None:\n            \"\"\"\n            Send both Control Change (CC) and Program Change (PC) messages to a MIDI target.\n\n            Args:\n                port (str): The name of the MIDI output port.\n                cc_channel (int): The MIDI channel to send the CC message on.\n                cc_control (int): The control number for the CC message.\n                cc_value (int): The value for the CC message.\n                pc_channel (int): The MIDI channel to send the PC message on.\n                pc_program (int): The program number for the PC message.\n            \"\"\"\n            cc_message = self._create_cc_message(cc_channel, cc_control, cc_value)\n            pc_message = self._create_pc_message(pc_channel, pc_program)\n            logging.debug(\"Sending CC message: %s\", cc_message)\n            logging.debug(\"Sending PC message: %s\", pc_message)\n            self._send_message(port, cc_message)\n            self._send_message(port, pc_message)\n\n        def _create_cc_message(self, channel: int, control: int, value: int) -&gt; mido.Message:\n            \"\"\"\n            Create a Control Change (CC) message.\n\n            Args:\n                channel (int): The MIDI channel to send the message on.\n                control (int): The control number.\n                value (int): The value to set the control to.\n\n            Returns:\n                mido.Message: The created CC message.\n            \"\"\"\n            return mido.Message('control_change', channel=channel, control=control, value=value)\n\n        def _create_pc_message(self, channel: int, program: int) -&gt; mido.Message:\n            \"\"\"\n            Create a Program Change (PC) message.\n\n            Args:\n                channel (int): The MIDI channel to send the message on.\n                program (int): The program number to change to.\n\n            Returns:\n                mido.Message: The created PC message.\n            \"\"\"\n            return mido.Message('program_change', channel=channel, program=program)\n\n        def _send_message(self, port: str, message: mido.Message) -&gt; None:\n            \"\"\"\n            Send a MIDI message to a specific MIDI target.\n\n            Args:\n                port (str): The name of the MIDI output port.\n                message (mido.Message): The MIDI message to send.\n            \"\"\"\n            with mido.open_output(port) as output:\n                output.send(message)\n                logging.debug(\"Sent message: %s to target: %s\", message, port)\n\n    class Targets:\n        \"\"\"\n        Targets class for managing desired MIDI output ports.\n\n        \"Targets\" are the MIDI output ports you want commands to be sent to.\n        Target names are saved in and loaded from the settings.yaml file.\n        \"\"\"\n        def __init__(self, system) -&gt; None:\n            self._settings = Settings()\n            self._system = system\n            self._items = self._load_targets()\n\n        def _load_targets(self) -&gt; List[str]:\n            \"\"\"\n            Load targets from settings if they match available ports.\n\n            Returns:\n                List[str]: A list of matched MIDI targets.\n            \"\"\"\n            saved_targets = self._settings.midi_targets\n            logging.debug(\"Saved MIDI targets: %s\", saved_targets)\n\n            matched_targets = []\n            for target in saved_targets:\n                if target in self._system.ports:\n                    matched_targets.append(target)\n                else:\n                    logging.warning(\"MIDI target '%s' not matched to any available port.\", target)\n            return matched_targets\n\n        def __getitem__(self, index):\n            return self._items[index]\n\n        def __setitem__(self, index, value):\n            self._items[index] = value\n\n        def __len__(self):\n            return len(self._items)\n\n        def __iter__(self):\n            return iter(self._items)\n\n        def __contains__(self, item):\n            return item in self._items\n\n        def save(self) -&gt; None:\n            \"\"\"\n            Save the current list of MIDI targets to the settings.\n            \"\"\"\n            settings_file = os.path.abspath(os.path.join(os.path.dirname(__file__), 'settings.yaml'))\n            with open(settings_file, 'w') as file:\n                yaml.safe_dump(self._items, file)\n            logging.debug(\"MIDI targets saved: %s\", self._items)\n\n        def add(self, target_name: str) -&gt; None:\n            \"\"\"\n            Add a MIDI target to the list of targets if it is not already present and is available.\n\n            Args:\n                target_name (str): The name of the MIDI target to add.\n            \"\"\"\n            if target_name in self._system.ports:\n                if target_name not in self._items:\n                    self._items.append(target_name)\n                    self.save()\n                    logging.debug(\"Added MIDI target: %s\", target_name)\n            else:\n                logging.warning(\"Cannot add MIDI target '%s': not available.\", target_name)\n\n        def remove(self, target_name: str) -&gt; None:\n            \"\"\"\n            Remove a MIDI target from the list of targets if it is present.\n\n            Args:\n                target_name (str): The name of the MIDI target to remove.\n            \"\"\"\n            if target_name in self._items:\n                self._items.remove(target_name)\n                self.save()\n                logging.debug(\"Removed MIDI target: %s\", target_name)\n\n    class Commands:\n        \"\"\"\n        Commands class for MIDI controllable commands to the Helix device.\n\n        This class eliminates the need to understand MIDI and the specific MIDI messages and order needed to communicate with a Helix device.\n        Instead, you simply call the commands you want (ex. change_to_setlist) and the class will take care of the rest.\n        \"\"\"\n        def __init__(self, targets) -&gt; None:\n            self.targets = targets\n\n        def change_to_setlist(self, setlist_index: int) -&gt; None:\n            \"\"\"\n            Change to a specific setlist on the Helix device.\n\n            Args:\n                setlist_index (int): The index of the setlist to change to.\n            \"\"\"\n            for target in self.targets:\n                self.targets.system.send_cc(port=target, channel=0, control=69, value=setlist_index)\n                logging.debug(\"Changed to setlist %d on target %s\", setlist_index, target)\n\n        def change_to_preset(self, preset_index: int) -&gt; None:\n            \"\"\"\n            Change to a specific preset on the Helix device.\n\n            Args:\n                preset_index (int): The index of the preset to change to.\n            \"\"\"\n            for target in self.targets:\n                self.targets.system.send_pc(port=target, channel=0, program=preset_index)\n                logging.debug(\"Changed to preset %d on target %s\", preset_index, target)\n\n        def change_to_snapshot(self, snapshot_index: int) -&gt; None:\n            \"\"\"\n            Change to a specific snapshot on the Helix device.\n\n            Args:\n                snapshot_index (int): The index of the snapshot to change to.\n            \"\"\"\n            for target in self.targets:\n                self.targets.system.send_cc(port=target, channel=0, control=69, value=snapshot_index)\n                logging.debug(\"Changed to snapshot %d on target %s\", snapshot_index, target)\n\n        def next_preset(self) -&gt; None:\n            \"\"\"\n            Change to the next preset on the Helix device.\n            \"\"\"\n            for target in self.targets:\n                self.targets.system.send_cc(port=target, channel=0, control=72, value=64)\n                logging.debug(\"Changed to next preset on target: %s\", target)\n\n        def previous_preset(self) -&gt; None:\n            \"\"\"\n            Change to the previous preset on the Helix device.\n            \"\"\"\n            for target in self.targets:\n                self.targets.system.send_cc(port=target, channel=0, control=72, value=0)\n                logging.debug(\"Changed to previous preset on target: %s\", target)\n\n        def next_snapshot(self) -&gt; None:\n            \"\"\"\n            Change to the next snapshot on the Helix device.\n            \"\"\"\n            for target in self.targets:\n                self.targets.system.send_cc(port=target, channel=0, control=69, value=8)\n                logging.debug(\"Changed to next snapshot on target: %s\", target)\n\n        def previous_snapshot(self) -&gt; None:\n            \"\"\"\n            Change to the previous snapshot on the Helix device.\n            \"\"\"\n            for target in self.targets:\n                self.targets.system.send_cc(port=target, channel=0, control=69, value=9)\n                logging.debug(\"Changed to previous snapshot on target: %s\", target)\n\n        def toggle_toe(self) -&gt; None:\n            \"\"\"\n            Toggles the toe switch on the Helix device.\n            \"\"\"\n            for device in self.devices:\n                self.devices.system.send_cc(port=device, channel=0, control=59, value=0)\n                logging.debug(\"Toggled toe switch on device: %s\", device)\n\n        def toggle_tuner(self) -&gt; None:\n            \"\"\"\n            Toggles the tuner on the Helix device.\n            \"\"\"\n            for device in self.devices:\n                self.devices.system.send_cc(port=device, channel=0, control=68, value=0)\n                logging.debug(\"Toggled tuner on device: %s\", device)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.commands","title":"<code>commands = self.Commands(self.targets)</code>  <code>instance-attribute</code>","text":""},{"location":"midi/#helixapi.midi.MIDI.system","title":"<code>system = self.System()</code>  <code>instance-attribute</code>","text":""},{"location":"midi/#helixapi.midi.MIDI.targets","title":"<code>targets = self.Targets(self.system)</code>  <code>instance-attribute</code>","text":""},{"location":"midi/#helixapi.midi.MIDI.Commands","title":"<code>Commands</code>","text":"<p>Commands class for MIDI controllable commands to the Helix device.</p> <p>This class eliminates the need to understand MIDI and the specific MIDI messages and order needed to communicate with a Helix device. Instead, you simply call the commands you want (ex. change_to_setlist) and the class will take care of the rest.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>class Commands:\n    \"\"\"\n    Commands class for MIDI controllable commands to the Helix device.\n\n    This class eliminates the need to understand MIDI and the specific MIDI messages and order needed to communicate with a Helix device.\n    Instead, you simply call the commands you want (ex. change_to_setlist) and the class will take care of the rest.\n    \"\"\"\n    def __init__(self, targets) -&gt; None:\n        self.targets = targets\n\n    def change_to_setlist(self, setlist_index: int) -&gt; None:\n        \"\"\"\n        Change to a specific setlist on the Helix device.\n\n        Args:\n            setlist_index (int): The index of the setlist to change to.\n        \"\"\"\n        for target in self.targets:\n            self.targets.system.send_cc(port=target, channel=0, control=69, value=setlist_index)\n            logging.debug(\"Changed to setlist %d on target %s\", setlist_index, target)\n\n    def change_to_preset(self, preset_index: int) -&gt; None:\n        \"\"\"\n        Change to a specific preset on the Helix device.\n\n        Args:\n            preset_index (int): The index of the preset to change to.\n        \"\"\"\n        for target in self.targets:\n            self.targets.system.send_pc(port=target, channel=0, program=preset_index)\n            logging.debug(\"Changed to preset %d on target %s\", preset_index, target)\n\n    def change_to_snapshot(self, snapshot_index: int) -&gt; None:\n        \"\"\"\n        Change to a specific snapshot on the Helix device.\n\n        Args:\n            snapshot_index (int): The index of the snapshot to change to.\n        \"\"\"\n        for target in self.targets:\n            self.targets.system.send_cc(port=target, channel=0, control=69, value=snapshot_index)\n            logging.debug(\"Changed to snapshot %d on target %s\", snapshot_index, target)\n\n    def next_preset(self) -&gt; None:\n        \"\"\"\n        Change to the next preset on the Helix device.\n        \"\"\"\n        for target in self.targets:\n            self.targets.system.send_cc(port=target, channel=0, control=72, value=64)\n            logging.debug(\"Changed to next preset on target: %s\", target)\n\n    def previous_preset(self) -&gt; None:\n        \"\"\"\n        Change to the previous preset on the Helix device.\n        \"\"\"\n        for target in self.targets:\n            self.targets.system.send_cc(port=target, channel=0, control=72, value=0)\n            logging.debug(\"Changed to previous preset on target: %s\", target)\n\n    def next_snapshot(self) -&gt; None:\n        \"\"\"\n        Change to the next snapshot on the Helix device.\n        \"\"\"\n        for target in self.targets:\n            self.targets.system.send_cc(port=target, channel=0, control=69, value=8)\n            logging.debug(\"Changed to next snapshot on target: %s\", target)\n\n    def previous_snapshot(self) -&gt; None:\n        \"\"\"\n        Change to the previous snapshot on the Helix device.\n        \"\"\"\n        for target in self.targets:\n            self.targets.system.send_cc(port=target, channel=0, control=69, value=9)\n            logging.debug(\"Changed to previous snapshot on target: %s\", target)\n\n    def toggle_toe(self) -&gt; None:\n        \"\"\"\n        Toggles the toe switch on the Helix device.\n        \"\"\"\n        for device in self.devices:\n            self.devices.system.send_cc(port=device, channel=0, control=59, value=0)\n            logging.debug(\"Toggled toe switch on device: %s\", device)\n\n    def toggle_tuner(self) -&gt; None:\n        \"\"\"\n        Toggles the tuner on the Helix device.\n        \"\"\"\n        for device in self.devices:\n            self.devices.system.send_cc(port=device, channel=0, control=68, value=0)\n            logging.debug(\"Toggled tuner on device: %s\", device)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.targets","title":"<code>targets = targets</code>  <code>instance-attribute</code>","text":""},{"location":"midi/#helixapi.midi.MIDI.Commands.change_to_preset","title":"<code>change_to_preset(preset_index)</code>","text":"<p>Change to a specific preset on the Helix device.</p> <p>Parameters:</p> Name Type Description Default <code>preset_index</code> <code>int</code> <p>The index of the preset to change to.</p> required Source code in <code>helixapi\\midi.py</code> <pre><code>def change_to_preset(self, preset_index: int) -&gt; None:\n    \"\"\"\n    Change to a specific preset on the Helix device.\n\n    Args:\n        preset_index (int): The index of the preset to change to.\n    \"\"\"\n    for target in self.targets:\n        self.targets.system.send_pc(port=target, channel=0, program=preset_index)\n        logging.debug(\"Changed to preset %d on target %s\", preset_index, target)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.change_to_setlist","title":"<code>change_to_setlist(setlist_index)</code>","text":"<p>Change to a specific setlist on the Helix device.</p> <p>Parameters:</p> Name Type Description Default <code>setlist_index</code> <code>int</code> <p>The index of the setlist to change to.</p> required Source code in <code>helixapi\\midi.py</code> <pre><code>def change_to_setlist(self, setlist_index: int) -&gt; None:\n    \"\"\"\n    Change to a specific setlist on the Helix device.\n\n    Args:\n        setlist_index (int): The index of the setlist to change to.\n    \"\"\"\n    for target in self.targets:\n        self.targets.system.send_cc(port=target, channel=0, control=69, value=setlist_index)\n        logging.debug(\"Changed to setlist %d on target %s\", setlist_index, target)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.change_to_snapshot","title":"<code>change_to_snapshot(snapshot_index)</code>","text":"<p>Change to a specific snapshot on the Helix device.</p> <p>Parameters:</p> Name Type Description Default <code>snapshot_index</code> <code>int</code> <p>The index of the snapshot to change to.</p> required Source code in <code>helixapi\\midi.py</code> <pre><code>def change_to_snapshot(self, snapshot_index: int) -&gt; None:\n    \"\"\"\n    Change to a specific snapshot on the Helix device.\n\n    Args:\n        snapshot_index (int): The index of the snapshot to change to.\n    \"\"\"\n    for target in self.targets:\n        self.targets.system.send_cc(port=target, channel=0, control=69, value=snapshot_index)\n        logging.debug(\"Changed to snapshot %d on target %s\", snapshot_index, target)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.next_preset","title":"<code>next_preset()</code>","text":"<p>Change to the next preset on the Helix device.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>def next_preset(self) -&gt; None:\n    \"\"\"\n    Change to the next preset on the Helix device.\n    \"\"\"\n    for target in self.targets:\n        self.targets.system.send_cc(port=target, channel=0, control=72, value=64)\n        logging.debug(\"Changed to next preset on target: %s\", target)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.next_snapshot","title":"<code>next_snapshot()</code>","text":"<p>Change to the next snapshot on the Helix device.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>def next_snapshot(self) -&gt; None:\n    \"\"\"\n    Change to the next snapshot on the Helix device.\n    \"\"\"\n    for target in self.targets:\n        self.targets.system.send_cc(port=target, channel=0, control=69, value=8)\n        logging.debug(\"Changed to next snapshot on target: %s\", target)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.previous_preset","title":"<code>previous_preset()</code>","text":"<p>Change to the previous preset on the Helix device.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>def previous_preset(self) -&gt; None:\n    \"\"\"\n    Change to the previous preset on the Helix device.\n    \"\"\"\n    for target in self.targets:\n        self.targets.system.send_cc(port=target, channel=0, control=72, value=0)\n        logging.debug(\"Changed to previous preset on target: %s\", target)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.previous_snapshot","title":"<code>previous_snapshot()</code>","text":"<p>Change to the previous snapshot on the Helix device.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>def previous_snapshot(self) -&gt; None:\n    \"\"\"\n    Change to the previous snapshot on the Helix device.\n    \"\"\"\n    for target in self.targets:\n        self.targets.system.send_cc(port=target, channel=0, control=69, value=9)\n        logging.debug(\"Changed to previous snapshot on target: %s\", target)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.toggle_toe","title":"<code>toggle_toe()</code>","text":"<p>Toggles the toe switch on the Helix device.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>def toggle_toe(self) -&gt; None:\n    \"\"\"\n    Toggles the toe switch on the Helix device.\n    \"\"\"\n    for device in self.devices:\n        self.devices.system.send_cc(port=device, channel=0, control=59, value=0)\n        logging.debug(\"Toggled toe switch on device: %s\", device)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Commands.toggle_tuner","title":"<code>toggle_tuner()</code>","text":"<p>Toggles the tuner on the Helix device.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>def toggle_tuner(self) -&gt; None:\n    \"\"\"\n    Toggles the tuner on the Helix device.\n    \"\"\"\n    for device in self.devices:\n        self.devices.system.send_cc(port=device, channel=0, control=68, value=0)\n        logging.debug(\"Toggled tuner on device: %s\", device)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.System","title":"<code>System</code>","text":"<p>System class for managing MIDI output ports and sending messages.</p> <p>Note</p> <p>While this class is mostly for internal use, it can be used to list MIDI output ports and send messages. Most users should use the Commands class instead.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>class System:\n    \"\"\"\n    System class for managing MIDI output ports and sending messages.\n\n    !!! note\n\n        While this class is mostly for internal use, it can be used to list MIDI output ports and send messages.\n        Most users should use the Commands class instead.\n    \"\"\"\n    def __init__(self) -&gt; None:\n        self._available_ports = mido.get_output_names()\n\n    @property\n    def ports(self) -&gt; List[str]:\n        \"\"\"\n        Return a list of available MIDI output ports.\n\n        Returns:\n            List[str]: A list of available MIDI output ports.\n        \"\"\"\n        logging.debug(\"Available MIDI ports: %s\", self._available_ports)\n        return self._available_ports\n\n    def send_cc(self, port: str, channel: int, control: int, value: int) -&gt; None:\n        \"\"\"\n        Send a Control Change (CC) message to a MIDI target.\n\n        Args:\n            port (str): The name of the MIDI output port.\n            channel (int): The MIDI channel to send the message on.\n            control (int): The control number.\n            value (int): The value to set the control to.\n        \"\"\"\n        message = self._create_cc_message(channel, control, value)\n        logging.debug(\"Sending CC message: %s\", message)\n        self._send_message(port, message)\n\n    def send_pc(self, port: str, channel: int, program: int) -&gt; None:\n        \"\"\"\n        Send a Program Change (PC) message to a MIDI target.\n\n        Args:\n            port (str): The name of the MIDI output port.\n            channel (int): The MIDI channel to send the message on.\n            program (int): The program number to change to.\n        \"\"\"\n        message = self._create_pc_message(channel, program)\n        logging.debug(\"Sending PC message: %s\", message)\n        self._send_message(port, message)\n\n    def send_ccpc(self, port: str, cc_channel: int, cc_control: int, cc_value: int, pc_channel: int, pc_program: int) -&gt; None:\n        \"\"\"\n        Send both Control Change (CC) and Program Change (PC) messages to a MIDI target.\n\n        Args:\n            port (str): The name of the MIDI output port.\n            cc_channel (int): The MIDI channel to send the CC message on.\n            cc_control (int): The control number for the CC message.\n            cc_value (int): The value for the CC message.\n            pc_channel (int): The MIDI channel to send the PC message on.\n            pc_program (int): The program number for the PC message.\n        \"\"\"\n        cc_message = self._create_cc_message(cc_channel, cc_control, cc_value)\n        pc_message = self._create_pc_message(pc_channel, pc_program)\n        logging.debug(\"Sending CC message: %s\", cc_message)\n        logging.debug(\"Sending PC message: %s\", pc_message)\n        self._send_message(port, cc_message)\n        self._send_message(port, pc_message)\n\n    def _create_cc_message(self, channel: int, control: int, value: int) -&gt; mido.Message:\n        \"\"\"\n        Create a Control Change (CC) message.\n\n        Args:\n            channel (int): The MIDI channel to send the message on.\n            control (int): The control number.\n            value (int): The value to set the control to.\n\n        Returns:\n            mido.Message: The created CC message.\n        \"\"\"\n        return mido.Message('control_change', channel=channel, control=control, value=value)\n\n    def _create_pc_message(self, channel: int, program: int) -&gt; mido.Message:\n        \"\"\"\n        Create a Program Change (PC) message.\n\n        Args:\n            channel (int): The MIDI channel to send the message on.\n            program (int): The program number to change to.\n\n        Returns:\n            mido.Message: The created PC message.\n        \"\"\"\n        return mido.Message('program_change', channel=channel, program=program)\n\n    def _send_message(self, port: str, message: mido.Message) -&gt; None:\n        \"\"\"\n        Send a MIDI message to a specific MIDI target.\n\n        Args:\n            port (str): The name of the MIDI output port.\n            message (mido.Message): The MIDI message to send.\n        \"\"\"\n        with mido.open_output(port) as output:\n            output.send(message)\n            logging.debug(\"Sent message: %s to target: %s\", message, port)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.System.ports","title":"<code>ports: List[str]</code>  <code>property</code>","text":"<p>Return a list of available MIDI output ports.</p> <p>Returns:</p> Type Description <code>List[str]</code> <p>List[str]: A list of available MIDI output ports.</p>"},{"location":"midi/#helixapi.midi.MIDI.System.send_cc","title":"<code>send_cc(port, channel, control, value)</code>","text":"<p>Send a Control Change (CC) message to a MIDI target.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The name of the MIDI output port.</p> required <code>channel</code> <code>int</code> <p>The MIDI channel to send the message on.</p> required <code>control</code> <code>int</code> <p>The control number.</p> required <code>value</code> <code>int</code> <p>The value to set the control to.</p> required Source code in <code>helixapi\\midi.py</code> <pre><code>def send_cc(self, port: str, channel: int, control: int, value: int) -&gt; None:\n    \"\"\"\n    Send a Control Change (CC) message to a MIDI target.\n\n    Args:\n        port (str): The name of the MIDI output port.\n        channel (int): The MIDI channel to send the message on.\n        control (int): The control number.\n        value (int): The value to set the control to.\n    \"\"\"\n    message = self._create_cc_message(channel, control, value)\n    logging.debug(\"Sending CC message: %s\", message)\n    self._send_message(port, message)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.System.send_ccpc","title":"<code>send_ccpc(port, cc_channel, cc_control, cc_value, pc_channel, pc_program)</code>","text":"<p>Send both Control Change (CC) and Program Change (PC) messages to a MIDI target.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The name of the MIDI output port.</p> required <code>cc_channel</code> <code>int</code> <p>The MIDI channel to send the CC message on.</p> required <code>cc_control</code> <code>int</code> <p>The control number for the CC message.</p> required <code>cc_value</code> <code>int</code> <p>The value for the CC message.</p> required <code>pc_channel</code> <code>int</code> <p>The MIDI channel to send the PC message on.</p> required <code>pc_program</code> <code>int</code> <p>The program number for the PC message.</p> required Source code in <code>helixapi\\midi.py</code> <pre><code>def send_ccpc(self, port: str, cc_channel: int, cc_control: int, cc_value: int, pc_channel: int, pc_program: int) -&gt; None:\n    \"\"\"\n    Send both Control Change (CC) and Program Change (PC) messages to a MIDI target.\n\n    Args:\n        port (str): The name of the MIDI output port.\n        cc_channel (int): The MIDI channel to send the CC message on.\n        cc_control (int): The control number for the CC message.\n        cc_value (int): The value for the CC message.\n        pc_channel (int): The MIDI channel to send the PC message on.\n        pc_program (int): The program number for the PC message.\n    \"\"\"\n    cc_message = self._create_cc_message(cc_channel, cc_control, cc_value)\n    pc_message = self._create_pc_message(pc_channel, pc_program)\n    logging.debug(\"Sending CC message: %s\", cc_message)\n    logging.debug(\"Sending PC message: %s\", pc_message)\n    self._send_message(port, cc_message)\n    self._send_message(port, pc_message)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.System.send_pc","title":"<code>send_pc(port, channel, program)</code>","text":"<p>Send a Program Change (PC) message to a MIDI target.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>str</code> <p>The name of the MIDI output port.</p> required <code>channel</code> <code>int</code> <p>The MIDI channel to send the message on.</p> required <code>program</code> <code>int</code> <p>The program number to change to.</p> required Source code in <code>helixapi\\midi.py</code> <pre><code>def send_pc(self, port: str, channel: int, program: int) -&gt; None:\n    \"\"\"\n    Send a Program Change (PC) message to a MIDI target.\n\n    Args:\n        port (str): The name of the MIDI output port.\n        channel (int): The MIDI channel to send the message on.\n        program (int): The program number to change to.\n    \"\"\"\n    message = self._create_pc_message(channel, program)\n    logging.debug(\"Sending PC message: %s\", message)\n    self._send_message(port, message)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Targets","title":"<code>Targets</code>","text":"<p>Targets class for managing desired MIDI output ports.</p> <p>\"Targets\" are the MIDI output ports you want commands to be sent to. Target names are saved in and loaded from the settings.yaml file.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>class Targets:\n    \"\"\"\n    Targets class for managing desired MIDI output ports.\n\n    \"Targets\" are the MIDI output ports you want commands to be sent to.\n    Target names are saved in and loaded from the settings.yaml file.\n    \"\"\"\n    def __init__(self, system) -&gt; None:\n        self._settings = Settings()\n        self._system = system\n        self._items = self._load_targets()\n\n    def _load_targets(self) -&gt; List[str]:\n        \"\"\"\n        Load targets from settings if they match available ports.\n\n        Returns:\n            List[str]: A list of matched MIDI targets.\n        \"\"\"\n        saved_targets = self._settings.midi_targets\n        logging.debug(\"Saved MIDI targets: %s\", saved_targets)\n\n        matched_targets = []\n        for target in saved_targets:\n            if target in self._system.ports:\n                matched_targets.append(target)\n            else:\n                logging.warning(\"MIDI target '%s' not matched to any available port.\", target)\n        return matched_targets\n\n    def __getitem__(self, index):\n        return self._items[index]\n\n    def __setitem__(self, index, value):\n        self._items[index] = value\n\n    def __len__(self):\n        return len(self._items)\n\n    def __iter__(self):\n        return iter(self._items)\n\n    def __contains__(self, item):\n        return item in self._items\n\n    def save(self) -&gt; None:\n        \"\"\"\n        Save the current list of MIDI targets to the settings.\n        \"\"\"\n        settings_file = os.path.abspath(os.path.join(os.path.dirname(__file__), 'settings.yaml'))\n        with open(settings_file, 'w') as file:\n            yaml.safe_dump(self._items, file)\n        logging.debug(\"MIDI targets saved: %s\", self._items)\n\n    def add(self, target_name: str) -&gt; None:\n        \"\"\"\n        Add a MIDI target to the list of targets if it is not already present and is available.\n\n        Args:\n            target_name (str): The name of the MIDI target to add.\n        \"\"\"\n        if target_name in self._system.ports:\n            if target_name not in self._items:\n                self._items.append(target_name)\n                self.save()\n                logging.debug(\"Added MIDI target: %s\", target_name)\n        else:\n            logging.warning(\"Cannot add MIDI target '%s': not available.\", target_name)\n\n    def remove(self, target_name: str) -&gt; None:\n        \"\"\"\n        Remove a MIDI target from the list of targets if it is present.\n\n        Args:\n            target_name (str): The name of the MIDI target to remove.\n        \"\"\"\n        if target_name in self._items:\n            self._items.remove(target_name)\n            self.save()\n            logging.debug(\"Removed MIDI target: %s\", target_name)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Targets.add","title":"<code>add(target_name)</code>","text":"<p>Add a MIDI target to the list of targets if it is not already present and is available.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>The name of the MIDI target to add.</p> required Source code in <code>helixapi\\midi.py</code> <pre><code>def add(self, target_name: str) -&gt; None:\n    \"\"\"\n    Add a MIDI target to the list of targets if it is not already present and is available.\n\n    Args:\n        target_name (str): The name of the MIDI target to add.\n    \"\"\"\n    if target_name in self._system.ports:\n        if target_name not in self._items:\n            self._items.append(target_name)\n            self.save()\n            logging.debug(\"Added MIDI target: %s\", target_name)\n    else:\n        logging.warning(\"Cannot add MIDI target '%s': not available.\", target_name)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Targets.remove","title":"<code>remove(target_name)</code>","text":"<p>Remove a MIDI target from the list of targets if it is present.</p> <p>Parameters:</p> Name Type Description Default <code>target_name</code> <code>str</code> <p>The name of the MIDI target to remove.</p> required Source code in <code>helixapi\\midi.py</code> <pre><code>def remove(self, target_name: str) -&gt; None:\n    \"\"\"\n    Remove a MIDI target from the list of targets if it is present.\n\n    Args:\n        target_name (str): The name of the MIDI target to remove.\n    \"\"\"\n    if target_name in self._items:\n        self._items.remove(target_name)\n        self.save()\n        logging.debug(\"Removed MIDI target: %s\", target_name)\n</code></pre>"},{"location":"midi/#helixapi.midi.MIDI.Targets.save","title":"<code>save()</code>","text":"<p>Save the current list of MIDI targets to the settings.</p> Source code in <code>helixapi\\midi.py</code> <pre><code>def save(self) -&gt; None:\n    \"\"\"\n    Save the current list of MIDI targets to the settings.\n    \"\"\"\n    settings_file = os.path.abspath(os.path.join(os.path.dirname(__file__), 'settings.yaml'))\n    with open(settings_file, 'w') as file:\n        yaml.safe_dump(self._items, file)\n    logging.debug(\"MIDI targets saved: %s\", self._items)\n</code></pre>"},{"location":"preset/","title":"Preset","text":""},{"location":"preset/#helixapi.preset.Preset","title":"<code>Preset</code>","text":"<p>               Bases: <code>ItemBase</code></p> <p>Represents a Helix preset for a given setlist. This contains specific metadata (index, name) and all snapshots.</p> Source code in <code>helixapi\\preset.py</code> <pre><code>class Preset(ItemBase):\n    \"\"\"\n    Represents a Helix preset for a given setlist. This contains specific metadata (index, name) and all snapshots.\n    \"\"\"\n\n    def __init__(self, data: dict, setlist_index: int, index: int, set_active_callback=None, metadata: dict = {}):\n        \"\"\"\n        Initialize the Preset class.\n\n        Args:\n            data (dict): The data structure representing the preset.\n            setlist_index (int): Index of the setlist containing this preset.\n            index (int): Index of this preset within its setlist.\n            set_active_callback (callable): Callback function to set the active preset.\n            metadata (dict, optional): Additional metadata for the preset. Defaults to {}.\n\n        Examples:\n        ``` py\n        preset = Preset(data, setlist_index=0, index=1)\n        ```\n        \"\"\"\n        super().__init__(cls=Preset, data=data, metadata=metadata, setlist_index=setlist_index, preset_index=index)\n        self.index = index\n        self._active = False\n        self._set_active_callback = set_active_callback\n\n        # Load the snapshots\n        self._snapshots = Snapshots(\n            data=data, \n            setlist_index=setlist_index, \n            preset_index=self.index,\n            get_active_callback=self._get_active_snapshot_index,\n            set_active_callback=self._set_active_snapshot_index\n        )\n\n    @property\n    def _active_snapshot_index(self):\n        \"\"\"\n        Get the current snapshot of the preset.\n\n        Returns:\n            int: The index of the current snapshot.\n\n        Examples:\n        ``` py\n        current_snapshot = preset.current_snapshot\n        ```\n        \"\"\"\n        return self._get_data(\"current_snapshot\")\n\n    @_active_snapshot_index.setter\n    def _active_snapshot_index(self, index):\n        self._set_data(\"current_snapshot\", index)\n\n    def _get_active_snapshot_index(self):\n        return self._active_snapshot_index\n\n    def _set_active_snapshot_index(self, index):\n        self._active_snapshot_index = index\n\n    @property\n    def snapshots(self):\n        \"\"\"\n        Get the snapshots of the preset.\n\n        Returns:\n            Snapshots: The snapshots of the preset.\n\n        Examples:\n        ``` py\n        preset.snapshots\n        ```\n        \"\"\"\n        return self._snapshots\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the preset.\n\n        Returns:\n            str: The name of the preset.\n\n        Examples:\n        ``` py\n        preset.name\n        ```\n        \"\"\"\n        return self._get_data(\"name\")\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        \"\"\"\n        Set the name of the preset.\n\n        Args:\n            value (str): The name to set for the preset.\n\n        Raises:\n            ValueError: If the name length exceeds the maximum allowed length.\n\n        Examples:\n        ``` py\n        preset.name = \"Preset 1\"\n        ```\n        \"\"\"\n        if len(value) &gt; 16:\n            raise ValueError(\"Name must be 16 characters or fewer.\")\n        self._set_data(\"name\", value)\n\n    def import_preset(self, file_path=None) -&gt; None:\n        \"\"\"\n        Import a preset from a file.\n\n        Args:\n            file_path (str): Path to the preset file to import.\n\n        Examples:\n        ``` py\n        preset.import_preset(\"preset.hlx\")\n        ```\n\n        Raises:\n        Exception: If the file path is not specified or the file type is incorrect.\n\n        Returns:\n        None\n        \"\"\"\n        self._import_file(file_path=file_path)\n\n    def export_preset(self, file_path=None) -&gt; None:\n        \"\"\"\n        Export a preset to a file.\n\n        Args:\n            file_path (str): Path to export the preset file to.\n\n        Examples:\n        ``` py\n        preset.export_preset(\"preset.hlx\")\n        ```\n\n        Raises:\n        Exception: If the file path is not specified or the file type is incorrect.\n\n        Returns:\n        None\n        \"\"\"\n        self._export_file(file_path=file_path)\n\n    def reset_preset(self) -&gt; None:\n        \"\"\"\n        Reset the preset to its default values.\n\n        Examples:\n        ``` py\n        preset.reset_preset()\n        ```\n\n        Returns:\n        None\n        \"\"\"\n        self.import_preset()\n\n    @property\n    def active(self):\n        \"\"\"\n        Get the preset as active.\n\n        Returns:\n            bool: True if the preset is active, False otherwise.\n\n        Examples:\n        ``` py\n        print(preset.active)\n        ```\n        \"\"\"\n        return self._active\n\n    @active.setter\n    def active(self, value):\n        \"\"\"\n        Set the preset as active.\n\n        Args:\n            value (bool): True to set the preset as active, False otherwise.\n\n        Examples:\n        ``` py\n        preset.active = True\n        ```\n        \"\"\"\n        if value and self._set_active_callback:\n            self._set_active_callback(self.index)\n        self._active = value\n</code></pre>"},{"location":"preset/#helixapi.preset.Preset.active","title":"<code>active</code>  <code>property</code> <code>writable</code>","text":"<p>Get the preset as active.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the preset is active, False otherwise.</p> <p>Examples: <pre><code>print(preset.active)\n</code></pre></p>"},{"location":"preset/#helixapi.preset.Preset.index","title":"<code>index = index</code>  <code>instance-attribute</code>","text":""},{"location":"preset/#helixapi.preset.Preset.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the name of the preset.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the preset.</p> <p>Examples: <pre><code>preset.name\n</code></pre></p>"},{"location":"preset/#helixapi.preset.Preset.snapshots","title":"<code>snapshots</code>  <code>property</code>","text":"<p>Get the snapshots of the preset.</p> <p>Returns:</p> Name Type Description <code>Snapshots</code> <p>The snapshots of the preset.</p> <p>Examples: <pre><code>preset.snapshots\n</code></pre></p>"},{"location":"preset/#helixapi.preset.Preset.export_preset","title":"<code>export_preset(file_path=None)</code>","text":"<p>Export a preset to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to export the preset file to.</p> <code>None</code> <p>Examples: <pre><code>preset.export_preset(\"preset.hlx\")\n</code></pre></p> <p>Raises: Exception: If the file path is not specified or the file type is incorrect.</p> <p>Returns: None</p> Source code in <code>helixapi\\preset.py</code> <pre><code>def export_preset(self, file_path=None) -&gt; None:\n    \"\"\"\n    Export a preset to a file.\n\n    Args:\n        file_path (str): Path to export the preset file to.\n\n    Examples:\n    ``` py\n    preset.export_preset(\"preset.hlx\")\n    ```\n\n    Raises:\n    Exception: If the file path is not specified or the file type is incorrect.\n\n    Returns:\n    None\n    \"\"\"\n    self._export_file(file_path=file_path)\n</code></pre>"},{"location":"preset/#helixapi.preset.Preset.import_preset","title":"<code>import_preset(file_path=None)</code>","text":"<p>Import a preset from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>Path to the preset file to import.</p> <code>None</code> <p>Examples: <pre><code>preset.import_preset(\"preset.hlx\")\n</code></pre></p> <p>Raises: Exception: If the file path is not specified or the file type is incorrect.</p> <p>Returns: None</p> Source code in <code>helixapi\\preset.py</code> <pre><code>def import_preset(self, file_path=None) -&gt; None:\n    \"\"\"\n    Import a preset from a file.\n\n    Args:\n        file_path (str): Path to the preset file to import.\n\n    Examples:\n    ``` py\n    preset.import_preset(\"preset.hlx\")\n    ```\n\n    Raises:\n    Exception: If the file path is not specified or the file type is incorrect.\n\n    Returns:\n    None\n    \"\"\"\n    self._import_file(file_path=file_path)\n</code></pre>"},{"location":"preset/#helixapi.preset.Preset.reset_preset","title":"<code>reset_preset()</code>","text":"<p>Reset the preset to its default values.</p> <p>Examples: <pre><code>preset.reset_preset()\n</code></pre></p> <p>Returns: None</p> Source code in <code>helixapi\\preset.py</code> <pre><code>def reset_preset(self) -&gt; None:\n    \"\"\"\n    Reset the preset to its default values.\n\n    Examples:\n    ``` py\n    preset.reset_preset()\n    ```\n\n    Returns:\n    None\n    \"\"\"\n    self.import_preset()\n</code></pre>"},{"location":"presets/","title":"Presets","text":""},{"location":"presets/#helixapi.presets.Presets","title":"<code>Presets</code>","text":"<p>               Bases: <code>CollectionBase</code></p> <p>Represents a collection of Helix presets for a given setlist.</p> Source code in <code>helixapi\\presets.py</code> <pre><code>class Presets(CollectionBase):\n    \"\"\"\n    Represents a collection of Helix presets for a given setlist.\n    \"\"\"\n    def __init__(self, data: dict=None, setlist_index: int=None):\n        \"\"\"\n        Initialize the Presets class.\n\n        Args:\n            data (dict): The data structure representing the setlist.\n            setlist_index (int): Index of the setlist containing this preset.\n\n        Examples:\n        ``` py\n        setlist = Setlist(data, index=0)\n        ```\n        \"\"\"\n        self._midi = MIDI()\n\n        super().__init__(cls=Preset, items=[Preset(data=data, setlist_index=setlist_index, index=i, set_active_callback=self._set_active_preset) for i in range(MAX_PRESETS)])\n\n        self._setlist_index = setlist_index\n        self._active_index = 0  # Set the first preset as active initially\n\n        # Ensure the initial active preset is correctly marked as active\n        if self._items:\n            self._items[self._active_index].active = True\n            self._set_active_preset(self._active_index)\n\n    def _set_active_preset(self, index):\n        self._active_index = index\n        self._midi.commands.change_to_preset(index)\n\n    @property\n    def active_index(self):\n        \"\"\"\n        Get the index of the active preset.\n\n        Returns:\n            int: The index of the active preset.\n        \"\"\"\n        return self._active_index\n\n    @active_index.setter\n    def active_index(self, index):\n        \"\"\"\n        Set the index of the active preset.\n\n        Args:\n            index (int): The index of the preset to set as active.\n        \"\"\"\n        self._set_active_preset(index)\n\n    @property\n    def active_item(self):\n        \"\"\"\n        Get the active preset.\n\n        Returns:\n            Preset: The active preset.\n        \"\"\"\n        return self._active_item\n\n    @active_item.setter\n    def active_item(self, item):\n        \"\"\"\n        Set the active preset.\n\n        Args:\n            item (Preset): The preset to set as active.\n        \"\"\"\n        self._active_item = item\n        self._set_active_preset(item.index)\n\n    def export_presets(self, file_path=None):\n        \"\"\"\n        Export presets to a single file.\n\n        Args:\n            file_path (str): The path to the file to export presets to. \n\n        Returns:\n            None\n        \"\"\"\n        self._export_files(file_path)\n\n    def import_presets(self, file_paths: List[str]):\n        \"\"\"\n        Import presets from multiple files.\n\n\n        !!! note\n\n\n            Preset order will follow the order of the provided file_paths (i.e. the first file path will be preset 1, etc)\n\n        Args:\n            file_paths (List[str]): List of file paths to import presets from.\n\n        Returns:\n            None\n        \"\"\"\n        self._import_files(file_paths)\n</code></pre>"},{"location":"presets/#helixapi.presets.Presets.active_index","title":"<code>active_index</code>  <code>property</code> <code>writable</code>","text":"<p>Get the index of the active preset.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The index of the active preset.</p>"},{"location":"presets/#helixapi.presets.Presets.active_item","title":"<code>active_item</code>  <code>property</code> <code>writable</code>","text":"<p>Get the active preset.</p> <p>Returns:</p> Name Type Description <code>Preset</code> <p>The active preset.</p>"},{"location":"presets/#helixapi.presets.Presets.export_presets","title":"<code>export_presets(file_path=None)</code>","text":"<p>Export presets to a single file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to export presets to. </p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>helixapi\\presets.py</code> <pre><code>def export_presets(self, file_path=None):\n    \"\"\"\n    Export presets to a single file.\n\n    Args:\n        file_path (str): The path to the file to export presets to. \n\n    Returns:\n        None\n    \"\"\"\n    self._export_files(file_path)\n</code></pre>"},{"location":"presets/#helixapi.presets.Presets.import_presets","title":"<code>import_presets(file_paths)</code>","text":"<p>Import presets from multiple files.</p> <p>Note</p> <p>Preset order will follow the order of the provided file_paths (i.e. the first file path will be preset 1, etc)</p> <p>Parameters:</p> Name Type Description Default <code>file_paths</code> <code>List[str]</code> <p>List of file paths to import presets from.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>helixapi\\presets.py</code> <pre><code>def import_presets(self, file_paths: List[str]):\n    \"\"\"\n    Import presets from multiple files.\n\n\n    !!! note\n\n\n        Preset order will follow the order of the provided file_paths (i.e. the first file path will be preset 1, etc)\n\n    Args:\n        file_paths (List[str]): List of file paths to import presets from.\n\n    Returns:\n        None\n    \"\"\"\n    self._import_files(file_paths)\n</code></pre>"},{"location":"setlist/","title":"Setlist","text":""},{"location":"setlist/#helixapi.setlist.Setlist","title":"<code>Setlist</code>","text":"<p>               Bases: <code>ItemBase</code></p> Source code in <code>helixapi\\setlist.py</code> <pre><code>class Setlist(ItemBase):\n    def __init__(self, data: dict, index: int, set_active_callback=None, metadata: dict = {}):\n        super().__init__(cls=Setlist, data=data, metadata=metadata, setlist_index=index)\n        self.index = index\n        self._active = False\n        self._set_active_callback = set_active_callback\n        self._presets = Presets(data=data, setlist_index=index)\n\n    @property\n    def presets(self):\n        \"\"\"\n        Get the presets for this setlist.\n\n        Returns:\n            Presets: The presets for this setlist.\n        \"\"\"\n        return self._presets\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the setlist.\n\n        Returns:\n            str: The name of the setlist.\n        \"\"\"\n        return self._get_data(\"name\")\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        \"\"\"\n        Set the name of the setlist.\n\n        Args:\n            value (str): The name to set for the setlist.\n\n        Raises:\n            ValueError: If the name length exceeds the maximum allowed length.\n        \"\"\"\n        if len(value) &gt; 16:\n            raise ValueError(\"Name must be 16 characters or fewer.\")\n        self._set_data(\"name\", value)\n\n    def import_setlist(self, file_path=None):\n        \"\"\"\n        Import a setlist from a file.\n\n        Args:\n            file_path (str, optional): The path to the file to import. Defaults to None.\n\n        Raises:\n            Exception: If the file path is not specified or the file type is incorrect.\n        \"\"\"\n        self._import_file(file_path=file_path)\n\n    def export_setlist(self, file_path=None):\n        \"\"\"\n        Export a setlist to a file.\n\n        Args:\n            file_path (str, optional): The path to the file to export. Defaults to None.\n\n        Raises:\n            Exception: If the file path is not specified or the file type is incorrect.\n        \"\"\"\n        self._export_file(file_path=file_path)\n\n    def reset_setlist(self):\n        \"\"\"\n        Reset the setlist to its default state.\n        \"\"\"\n        self.import_setlist()\n        self.name = f\"SETLIST {self.index + 1}\"\n\n    @property\n    def active(self):\n        \"\"\"\n        Get the active state of the setlist.\n\n        Returns:\n            bool: True if the setlist is active, False otherwise.\n        \"\"\"\n        return self._active\n\n    @active.setter\n    def active(self, value):\n        \"\"\"\n        Set the active state of the setlist.\n\n        Args:\n            value (bool): True to set the setlist as active, False otherwise.\n        \"\"\"\n        if value and self._set_active_callback:\n            self._set_active_callback(self.index)\n        self._active = value\n</code></pre>"},{"location":"setlist/#helixapi.setlist.Setlist.active","title":"<code>active</code>  <code>property</code> <code>writable</code>","text":"<p>Get the active state of the setlist.</p> <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the setlist is active, False otherwise.</p>"},{"location":"setlist/#helixapi.setlist.Setlist.index","title":"<code>index = index</code>  <code>instance-attribute</code>","text":""},{"location":"setlist/#helixapi.setlist.Setlist.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the name of the setlist.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the setlist.</p>"},{"location":"setlist/#helixapi.setlist.Setlist.presets","title":"<code>presets</code>  <code>property</code>","text":"<p>Get the presets for this setlist.</p> <p>Returns:</p> Name Type Description <code>Presets</code> <p>The presets for this setlist.</p>"},{"location":"setlist/#helixapi.setlist.Setlist.export_setlist","title":"<code>export_setlist(file_path=None)</code>","text":"<p>Export a setlist to a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to export. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the file path is not specified or the file type is incorrect.</p> Source code in <code>helixapi\\setlist.py</code> <pre><code>def export_setlist(self, file_path=None):\n    \"\"\"\n    Export a setlist to a file.\n\n    Args:\n        file_path (str, optional): The path to the file to export. Defaults to None.\n\n    Raises:\n        Exception: If the file path is not specified or the file type is incorrect.\n    \"\"\"\n    self._export_file(file_path=file_path)\n</code></pre>"},{"location":"setlist/#helixapi.setlist.Setlist.import_setlist","title":"<code>import_setlist(file_path=None)</code>","text":"<p>Import a setlist from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to the file to import. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>Exception</code> <p>If the file path is not specified or the file type is incorrect.</p> Source code in <code>helixapi\\setlist.py</code> <pre><code>def import_setlist(self, file_path=None):\n    \"\"\"\n    Import a setlist from a file.\n\n    Args:\n        file_path (str, optional): The path to the file to import. Defaults to None.\n\n    Raises:\n        Exception: If the file path is not specified or the file type is incorrect.\n    \"\"\"\n    self._import_file(file_path=file_path)\n</code></pre>"},{"location":"setlist/#helixapi.setlist.Setlist.reset_setlist","title":"<code>reset_setlist()</code>","text":"<p>Reset the setlist to its default state.</p> Source code in <code>helixapi\\setlist.py</code> <pre><code>def reset_setlist(self):\n    \"\"\"\n    Reset the setlist to its default state.\n    \"\"\"\n    self.import_setlist()\n    self.name = f\"SETLIST {self.index + 1}\"\n</code></pre>"},{"location":"setlists/","title":"Setlists","text":""},{"location":"setlists/#helixapi.setlists.Setlists","title":"<code>Setlists</code>","text":"<p>               Bases: <code>CollectionBase</code></p> <p>Represents a collection of Helix setlists.</p> Source code in <code>helixapi\\setlists.py</code> <pre><code>class Setlists(CollectionBase):\n    \"\"\"\n    Represents a collection of Helix setlists.\n    \"\"\"\n    def __init__(self, data: dict=None):\n        self._midi = MIDI()\n\n        super().__init__(cls=Setlist, items=[Setlist(data=data, index=i, set_active_callback=self._set_active_setlist) for i in range(MAX_SETLISTS)])\n\n        self._set_active_setlist(0)  # Set the first setlist as active initially\n\n        # Ensure the initial active setlist is correctly marked as active\n        if self._items:\n            self._items[self._active_index].active = True\n\n    def _set_active_setlist(self, index):\n        self._active_index = index\n        self._midi.commands.change_to_setlist(self._active_index)\n\n    @property\n    def active_index(self):\n        \"\"\"\n        Get the index of the active setlist.\n\n        Returns:\n            int: The index of the active setlist.\n        \"\"\"\n        return self._active_index\n\n    @active_index.setter\n    def active_index(self, index):\n        \"\"\"\n        Set the index of the active setlist.\n\n        Args:\n            index (int): The index of the setlist to set as active.\n        \"\"\"\n        self._set_active_setlist(index)\n\n    @property\n    def active_item(self):\n        \"\"\"\n        Get the active setlist.\n\n        Returns:\n            Setlist: The active setlist.\n        \"\"\"\n        return self._active_item\n\n    @active_item.setter\n    def active_item(self, item):\n        \"\"\"\n        Set the active setlist.\n\n        Args:\n            item (Setlist): The setlist to set as active.\n        \"\"\"\n        self._active_item = item\n        self._set_active_setlist(item.index)\n\n    def export_setlists(self, file_path=None):\n        \"\"\"\n        Export each setlist to individual files.\n\n        Args:\n            file_path (str): The path to export the setlists to.\n\n        Examples:\n        ``` py\n        setlists.export_setlists(file_path=\"/path/to/setlists\")\n        ```\n\n        Returns:\n            None\n        \"\"\"\n        self._export_files(file_path)\n\n    def import_setlists(self, file_paths: List[str]):\n        \"\"\"\n        Import each setlist from individual files.\n\n        !!! note\n\n\n            Setlist order will follow the order of the provided file_paths (i.e. the first file path will be setlist 1, etc)\n\n        Args:\n            file_paths (List[str]): The paths to import the setlists from.\n\n        Examples:\n        ``` py\n        setlists.import_setlists(file_paths=[\"/path/to/setlist1\", \"/path/to/setlist2\"])\n        ```\n\n        Returns:\n            None\n        \"\"\"\n        self._import_files(file_paths)\n</code></pre>"},{"location":"setlists/#helixapi.setlists.Setlists.active_index","title":"<code>active_index</code>  <code>property</code> <code>writable</code>","text":"<p>Get the index of the active setlist.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The index of the active setlist.</p>"},{"location":"setlists/#helixapi.setlists.Setlists.active_item","title":"<code>active_item</code>  <code>property</code> <code>writable</code>","text":"<p>Get the active setlist.</p> <p>Returns:</p> Name Type Description <code>Setlist</code> <p>The active setlist.</p>"},{"location":"setlists/#helixapi.setlists.Setlists.export_setlists","title":"<code>export_setlists(file_path=None)</code>","text":"<p>Export each setlist to individual files.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path to export the setlists to.</p> <code>None</code> <p>Examples: <pre><code>setlists.export_setlists(file_path=\"/path/to/setlists\")\n</code></pre></p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>helixapi\\setlists.py</code> <pre><code>def export_setlists(self, file_path=None):\n    \"\"\"\n    Export each setlist to individual files.\n\n    Args:\n        file_path (str): The path to export the setlists to.\n\n    Examples:\n    ``` py\n    setlists.export_setlists(file_path=\"/path/to/setlists\")\n    ```\n\n    Returns:\n        None\n    \"\"\"\n    self._export_files(file_path)\n</code></pre>"},{"location":"setlists/#helixapi.setlists.Setlists.import_setlists","title":"<code>import_setlists(file_paths)</code>","text":"<p>Import each setlist from individual files.</p> <p>Note</p> <p>Setlist order will follow the order of the provided file_paths (i.e. the first file path will be setlist 1, etc)</p> <p>Parameters:</p> Name Type Description Default <code>file_paths</code> <code>List[str]</code> <p>The paths to import the setlists from.</p> required <p>Examples: <pre><code>setlists.import_setlists(file_paths=[\"/path/to/setlist1\", \"/path/to/setlist2\"])\n</code></pre></p> <p>Returns:</p> Type Description <p>None</p> Source code in <code>helixapi\\setlists.py</code> <pre><code>def import_setlists(self, file_paths: List[str]):\n    \"\"\"\n    Import each setlist from individual files.\n\n    !!! note\n\n\n        Setlist order will follow the order of the provided file_paths (i.e. the first file path will be setlist 1, etc)\n\n    Args:\n        file_paths (List[str]): The paths to import the setlists from.\n\n    Examples:\n    ``` py\n    setlists.import_setlists(file_paths=[\"/path/to/setlist1\", \"/path/to/setlist2\"])\n    ```\n\n    Returns:\n        None\n    \"\"\"\n    self._import_files(file_paths)\n</code></pre>"},{"location":"settings/","title":"Settings","text":"<p><code>Helix-py-api</code> will work fine without any additonal configuration. If you need or wish to change some of the default behavior, simply set the values in the API settings file helixapi/utils/settings.yaml.</p> <pre><code>log_level: DEBUG\nmidi:\n  targets:\n    - \"Line 6 Helix 9\"\nstandards:\n  setlist:\n    casing: UPPERCASE\n    replacements:\n      \" \":\n        - \"_\"\n\n  preset:\n    casing: UPPERCASE\n    replacements:\n      \" \":\n        - \"_\"\n      \"Preset\":\n        - \"New Preset\"\n\n  snapshot:\n    casing: UPPERCASE\n    replacements:\n      \" \":\n        - \"_\"\n      \"Solo\":\n        - \"lead\"\n</code></pre> <p>For example, if you plan to use MIDI (i.e. have the API send commands to a Helix or other MIDI device), you will need to configure the \"midi\" section.</p>"},{"location":"snapshot/","title":"Snapshot","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor","title":"<code>LEDColor</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Available LED colors for Helix snapshots.</p> Source code in <code>helixapi\\snapshot.py</code> <pre><code>class LEDColor(Enum):\n    \"\"\"Available LED colors for Helix snapshots.\"\"\"\n    AUTO = 0\n    WHITE = 1\n    RED = 2\n    DARK_ORANGE = 3\n    LIGHT_ORANGE = 4\n    YELLOW = 5\n    GREEN = 6\n    TURQUOISE = 7\n    BLUE = 8\n    VIOLET = 9\n    PINK = 10\n    OFF = 11\n</code></pre>"},{"location":"snapshot/#helixapi.snapshot.LEDColor.AUTO","title":"<code>AUTO = 0</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.BLUE","title":"<code>BLUE = 8</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.DARK_ORANGE","title":"<code>DARK_ORANGE = 3</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.GREEN","title":"<code>GREEN = 6</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.LIGHT_ORANGE","title":"<code>LIGHT_ORANGE = 4</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.OFF","title":"<code>OFF = 11</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.PINK","title":"<code>PINK = 10</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.RED","title":"<code>RED = 2</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.TURQUOISE","title":"<code>TURQUOISE = 7</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.VIOLET","title":"<code>VIOLET = 9</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.WHITE","title":"<code>WHITE = 1</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.LEDColor.YELLOW","title":"<code>YELLOW = 5</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.Snapshot","title":"<code>Snapshot</code>","text":"<p>               Bases: <code>ItemBase</code></p> <p>Represents a Helix snapshot for a given preset. This contains specific metadata (index, name).</p> Source code in <code>helixapi\\snapshot.py</code> <pre><code>class Snapshot(ItemBase):\n    \"\"\"\n    Represents a Helix snapshot for a given preset. This contains specific metadata (index, name).\n    \"\"\"\n\n    def __init__(self, data: dict, setlist_index: int, preset_index: int, index: int, get_active_callback=None, set_active_callback=None, metadata: dict = {}) -&gt; None:\n        \"\"\"\n        Initialize the Snapshot class.\n\n        Args:\n            data (dict): The data structure representing the snapshot.\n            setlist_index (int): Index of the setlist containing this snapshot.\n            preset_index (int): Index of the preset containing this snapshot.\n            index (int): Index of this snapshot within its preset.\n            get_active_callback (callable): Callback function to get the active snapshot.\n            set_active_callback (callable): Callback function to set the active snapshot.\n            metadata (dict, optional): Additional metadata for the snapshot. Defaults to {}.\n\n        Examples:\n        ``` py\n        snapshot = Snapshot(data, setlist_index=0, preset_index=1, index=2)\n        ```\n        \"\"\"\n        super().__init__(cls=Snapshot, data=data, metadata=metadata, setlist_index=setlist_index, preset_index=preset_index, snapshot_index=index)\n        self.index = index\n        self._get_active_callback = get_active_callback\n        self._set_active_callback = set_active_callback\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"\n        Get the name of the snapshot.\n\n        Returns:\n            str: The name of the snapshot.\n\n        Examples:\n        ``` py\n        snapshot.name\n        ```\n        \"\"\"\n        return self._get_data(\"name\")\n\n    @name.setter\n    def name(self, value: str) -&gt; None:\n        \"\"\"\n        Set the name of the snapshot.\n\n        Args:\n            value (str): The name to set for the snapshot.\n\n        Raises:\n            ValueError: If the name length exceeds the maximum allowed length.\n\n        Examples:\n        ``` py\n        snapshot.name = \"Clean Tone\"\n        ```\n        \"\"\"\n        if len(value) &gt; 16:\n            raise ValueError(\"Name must be 16 characters or fewer.\")\n        self._set_data(\"name\", value)\n\n    @property\n    def ledcolor(self) -&gt; LEDColor:\n        \"\"\"\n        Get the LED color of the snapshot.\n\n        Returns:\n            LEDColor: The LED color of the snapshot.\n\n        Examples:\n        ``` py\n        prnit(snapshot.ledcolor)\n        ```\n        \"\"\"\n        return self._get_data(\"ledcolor\")\n\n    @ledcolor.setter\n    def ledcolor(self, value: LEDColor) -&gt; None:\n        \"\"\"\n        Set the LED color of the snapshot.\n\n        Args:\n            value (LEDColor): The LED color to set for the snapshot.\n\n        Raises:\n            ValueError: If the value is not a valid LEDColor enum.\n\n        Examples:\n        ``` py\n        snapshot.ledcolor = LEDColor.RED\n        ```\n        \"\"\"\n        if not isinstance(value, LEDColor):\n            raise ValueError(\"Invalid LED color value.\")\n        self._set_data(\"ledcolor\", value)\n\n    @property\n    def active(self) -&gt; bool:\n        \"\"\"\n        Check if the snapshot is active.\n\n        Returns:\n            bool: True if the snapshot is active, False otherwise.\n        \"\"\"\n        if self._get_active_callback:\n            return self._get_active_callback() == self.index\n        return False\n\n    @active.setter\n    def active(self, value: bool) -&gt; None:\n        \"\"\"\n        Set the snapshot as active.\n\n        Args:\n            value (bool): True to set the snapshot as active, False otherwise.\n        \"\"\"\n        if value and self._set_active_callback:\n            self._set_active_callback(self.index)\n</code></pre>"},{"location":"snapshot/#helixapi.snapshot.Snapshot.active","title":"<code>active: bool</code>  <code>property</code> <code>writable</code>","text":"<p>Check if the snapshot is active.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the snapshot is active, False otherwise.</p>"},{"location":"snapshot/#helixapi.snapshot.Snapshot.index","title":"<code>index = index</code>  <code>instance-attribute</code>","text":""},{"location":"snapshot/#helixapi.snapshot.Snapshot.ledcolor","title":"<code>ledcolor: LEDColor</code>  <code>property</code> <code>writable</code>","text":"<p>Get the LED color of the snapshot.</p> <p>Returns:</p> Name Type Description <code>LEDColor</code> <code>LEDColor</code> <p>The LED color of the snapshot.</p> <p>Examples: <pre><code>prnit(snapshot.ledcolor)\n</code></pre></p>"},{"location":"snapshot/#helixapi.snapshot.Snapshot.name","title":"<code>name: str</code>  <code>property</code> <code>writable</code>","text":"<p>Get the name of the snapshot.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the snapshot.</p> <p>Examples: <pre><code>snapshot.name\n</code></pre></p>"},{"location":"snapshots/","title":"Snapshots","text":""},{"location":"snapshots/#helixapi.snapshots.Snapshots","title":"<code>Snapshots</code>","text":"<p>               Bases: <code>CollectionBase</code></p> <p>Represents a collection of Helix snapshots for a given preset.</p> Source code in <code>helixapi\\snapshots.py</code> <pre><code>class Snapshots(CollectionBase):\n    \"\"\"\n    Represents a collection of Helix snapshots for a given preset.\n    \"\"\"\n    def __init__(self, data: dict=None, setlist_index: int=None, preset_index: int=None, get_active_callback=None, set_active_callback=None):\n        \"\"\"\n        Initialize the Snapshots class.\n\n        Args:\n            data (dict): The data structure representing the setlist.\n            setlist_index (int): Index of the setlist containing this snapshot.\n            preset_index (int): Index of the preset containing this snapshot.\n            get_active_callback (callable): Callback function to get the active snapshot index.\n            set_active_callback (callable): Callback function to set the active snapshot index.\n\n        Examples:\n        ``` py\n        setlist = Setlist(data, index=0)\n        ```\n        \"\"\"\n        self._midi = MIDI()\n        super().__init__()\n        self._setlist_index = setlist_index\n        self._preset_index = preset_index\n        self._get_active_callback = get_active_callback\n        self._set_active_callback = set_active_callback\n\n        self._items = [\n            Snapshot(\n                data=data, \n                index=i, \n                setlist_index=setlist_index, \n                preset_index=preset_index, \n                get_active_callback=self._get_active_index,\n                set_active_callback=self._set_active_snapshot\n            ) \n            for i in range(MAX_SNAPSHOTS)\n        ]\n\n    @property\n    def active_index(self):\n        \"\"\"\n        Get the index of the active snapshot.\n\n        Returns:\n            int: The index of the active snapshot.\n        \"\"\"\n        return self._get_active_index()\n\n    @active_index.setter\n    def active_index(self, index):\n        \"\"\"\n        Set the index of the active snapshot.\n\n        Args:\n            index (int): The index of the snapshot to set as active.\n        \"\"\"\n        self._set_active_index(index)\n\n    @property\n    def active_item(self):\n        \"\"\"\n        Get the active snapshot.\n\n        Returns:\n            Snapshot: The active snapshot.\n        \"\"\"\n        return self._items[self.active_index]\n\n    @active_item.setter\n    def active_item(self, item):\n        \"\"\"\n        Set the active snapshot.\n\n        Args:\n            item (Snapshot): The snapshot to set as active.\n        \"\"\"\n        self._set_active_index(self._items.index(item))\n\n    def _get_active_index(self):\n        \"\"\"\n        Get the index of the active snapshot.\n\n        Returns:\n            int: The index of the active snapshot.\n        \"\"\"\n        if self._get_active_callback:\n            return self._get_active_callback()\n        else:\n            return 0\n\n    def _set_active_index(self, index):\n        \"\"\"\n        Set the index of the active snapshot.\n\n        Args:\n            index (int): The index of the snapshot to set as active.\n        \"\"\"\n        if self._set_active_callback:\n            self._set_active_callback(index)\n\n        # Update the active state of snapshots\n        for snapshot in self._items:\n            snapshot._active = snapshot.index == index\n\n        self._midi.commands.change_to_snapshot(index)\n\n    def _set_active_snapshot(self, index):\n        \"\"\"\n        Callback to set the active snapshot.\n\n        Args:\n            index (int): The index of the snapshot to set as active.\n        \"\"\"\n        self._set_active_index(index)\n</code></pre>"},{"location":"snapshots/#helixapi.snapshots.Snapshots.active_index","title":"<code>active_index</code>  <code>property</code> <code>writable</code>","text":"<p>Get the index of the active snapshot.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The index of the active snapshot.</p>"},{"location":"snapshots/#helixapi.snapshots.Snapshots.active_item","title":"<code>active_item</code>  <code>property</code> <code>writable</code>","text":"<p>Get the active snapshot.</p> <p>Returns:</p> Name Type Description <code>Snapshot</code> <p>The active snapshot.</p>"}]}